# Super and Subclass in Java

Understanding the concepts of superclass and subclass is fundamental to mastering inheritance in Java. The superclass defines common behavior and attributes, while the subclass extends those functionalities, adds new features, and customizes existing methods for specialized use cases.

***

## What are Superclass and Subclass?

- **Superclass** (parent): The class whose properties and behaviors (fields and methods) are inherited.
- **Subclass** (child): The class that inherits properties from the superclass, adds new features, or modifies inherited ones.

The relationship between them is established using the `extends` keyword.

***

### Why Use Superclasses and Subclasses?

- **Code reuse:** Common logic is centralized in one class.
- **Modularity:** Behaviors are separated and organized hierarchically.
- **Scalability:** New features are incrementally built on top of base functionality.
- **Polymorphism:** Allows subclasses to be treated as their parent types for flexible code design.

***

## Basic Example: Defining and Using Superclass and Subclass

```java
// Superclass
class Animal {
    String type = "Animal";
    void eat() {
        System.out.println("Animals eat food");
    }
}

// Subclass
class Dog extends Animal {
    String name = "Fido";
    void bark() {
        System.out.println(name + " barks");
    }
}

class Main {
    public static void main(String[] args) {
        Dog d = new Dog();
        System.out.println(d.type);  // Inherited from Animal
        d.eat();                     // Inherited method
        d.bark();                    // Subclass method
    }
}
```


***

### Step-by-Step Explanation with Visuals

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Create Dog object | Dog constructor runs, inherits from Animal |
| 2 | Access 'type' attribute | Inherited from Animal, prints "Animal" |
| 3 | Call eat() method | Inherited from Animal, prints "Animals eat food" |
| 4 | Call bark() method | Unique to Dog, prints "Fido barks" |

**Visual Representation:**

```
Heap:
  Dog Object
  -------------
  type (inherited from Animal)
  name (defined in Dog)
  eat() (inherited)
  bark() (defined in Dog)
  -------------
```


***

## Super Keyword in Java

The `super` keyword bridges the subclass to its superclass, allowing the child class to invoke and reference its parent's methods, fields, and constructors with clarity and precision.

### Common Uses of `super`

1. **Accessing superclass variables:** When subclass has a field with the same name as the superclass, use `super.fieldName` to resolve ambiguity.
2. **Calling superclass methods:** Use `super.methodName()` to call the parent’s version in case of overriding.
3. **Invoking the superclass constructor:** Use `super()` as the first statement in a subclass constructor to ensure proper parent object initialization.

***

### Detailed Example: Variable and Method Resolution with `super`

```java
class Animal {
    String sound = "Some sound";
    void makeSound() {
        System.out.println(sound);
    }
}

class Cat extends Animal {
    String sound = "Meow";
    void makeSound() {
        System.out.println(sound);          // Prints "Meow"
        System.out.println(super.sound);    // Prints "Some sound"
        super.makeSound();                  // Calls Animal's makeSound
    }
}

class Test {
    public static void main(String[] args) {
        Cat c = new Cat();
        c.makeSound();
    }
}
```

**Output:**

```
Meow
Some sound
Some sound
```


#### Key Insight:

- When subclass and superclass share member names, `super` ensures you can distinguish and directly access the parent’s version.

***

## Constructor Chaining Using `super()`

A subclass can call its parent’s constructor using `super()`. This is mandatory if the parent does not have a no-argument constructor, and it must be the first line in the subclass constructor.

### In-Depth Example

```java
class Person {
    String name;
    Person(String name) {
        this.name = name;
        System.out.println("Person created: " + name);
    }
}

class Student extends Person {
    int rollNo;
    Student(String name, int rollNo) {
        super(name); // Calls Person(String name) constructor
        this.rollNo = rollNo;
        System.out.println("Student created: " + name + ", Roll No: " + rollNo);
    }
}

class Main {
    public static void main(String[] args) {
        Student s = new Student("Alice", 101);
    }
}
```

**Output:**

```
Person created: Alice
Student created: Alice, Roll No: 101
```


***

### Step-by-Step Explanation with Visuals

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Student object creation | Calls Student constructor |
| 2 | Calls super(name) | Invokes Person constructor to initialize inherited fields |
| 3 | Person sets name | Prints "Person created: Alice" |
| 4 | Student sets rollNo | Prints "Student created: Alice, Roll No: 101" |

**Visual Representation:**

```
Heap:
  Student Object
  -------------
  name (from Person)
  rollNo (from Student)
  -------------
```

- The `super()` chain ensures base class setup before subclass customization.

***

## Access Modifiers and Inheritance

- **private** members are *not* inherited.
- **protected** members are inherited but accessible only within subclasses and package.
- **public** members are inherited and accessible everywhere.


### Example of Inheritance and Access

```java
class Parent {
    private int a = 10;
    protected int b = 20;
    public int c = 30;
}

class Child extends Parent {
    void show() {
        // System.out.println(a); // Error: private
        System.out.println(b);    // Accessible: protected
        System.out.println(c);    // Accessible: public
    }
}
```


***

## Polymorphism via Superclass Reference

A superclass reference can hold a subclass object, enabling polymorphism:

```java
Animal animalRef = new Dog();
animalRef.eat();   // Calls Dog's overridden version if available
```

- Enables dynamic method dispatch, where the actual executed method depends on the object's runtime type.

***

## Summary Table: Superclass vs Subclass

| Feature | Superclass | Subclass |
| :-- | :-- | :-- |
| Definition | Base for inheritance | Derived from superclass |
| Members | Common attributes/methods | Inherits + adds/overrides |
| Accessibility | All except private | All inheritable members |
| Construction | Instantiated first | Calls superclass via super() |
| Reference | Can hold any subclass | Specialized or extended type |
| Polymorphism | Enables runtime binding | Supports overriding |


***

## Additional Insights

- The superclass forms the backbone of abstraction; all essential functionality is centralized there.
- The subclass builds on its parent, refining, extending, and providing specialized features without rewriting code.
- Use of `super` prevents bugs due to member name hiding and ensures correct initialization order for reliable software.
- The interplay between super and subclass powers inheritance, encapsulation, and polymorphism—the pillars of Java’s OOP paradigm.

***

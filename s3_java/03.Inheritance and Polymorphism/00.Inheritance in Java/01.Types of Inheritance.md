# Types of Inheritance in Java

Inheritance forms the backbone of Java’s object-oriented system. The way classes relate determines reuse, complexity, and code clarity. Java supports several types—in theory—but only implements a subset directly due to ambiguity and design limitations.

***

## What are the Types of Inheritance?

In Java, inheritance types are:

- Single Inheritance
- Multilevel Inheritance
- Hierarchical Inheritance
- Multiple Inheritance (not allowed in classes)
- Hybrid Inheritance

Each pattern offers different benefits and challenges for organizing code, and understanding them clarifies Java’s design philosophy and practical usage.

***

## Single Inheritance

Single inheritance means each class inherits from only one other class—forming a straight, one-to-one parent-child relationship.

### Why single inheritance?

- Prevents ambiguity in method and field resolution.
- Makes code more maintainable and predictable.
- Models real-world one-to-one relationships, where a specific child comes from a specific parent.

**Expanded Example:**

```java
class Vehicle {
    Vehicle() {
        System.out.println("Vehicle is created");
    }
    void move() {
        System.out.println("Vehicle can move");
    }
}
class Car extends Vehicle {
    Car() {
        System.out.println("Car is created");
    }
    void drive() {
        System.out.println("Car is driving");
    }
}
class Test {
    public static void main(String[] args) {
        Car myCar = new Car();
        myCar.move();
        myCar.drive();
    }
}
```


### Step-by-Step

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Car object creation | Car constructor runs, Vehicle constructor runs first |
| 2 | Vehicle constructor output | "Vehicle is created" printed |
| 3 | Car constructor output | "Car is created" printed |
| 4 | move() called | Inherited method runs, prints "Vehicle can move" |
| 5 | drive() called | Subclass-specific behavior, prints "Car is driving" |

**Visual Representation:**

```
Heap:
  Car Object
  -------------
  Vehicle fields/methods (inherited)
  Car fields/methods (defined)
  -------------
```

- Maintains a single, direct path of inheritance for clarity.

***

## Multilevel Inheritance

Multilevel inheritance chains classes together, with each derived class serving as a parent to the next.

### Why multilevel inheritance?

- Enables stepwise specializations—each subclass adds or extends features.
- Models generational hierarchies (grandparent → parent → child).

**Expanded Example:**

```java
class Animal {
    Animal() {
        System.out.println("Animal created");
    }
    void eat() {
        System.out.println("Animal eats");
    }
}
class Mammal extends Animal {
    Mammal() {
        System.out.println("Mammal created");
    }
    void walk() {
        System.out.println("Mammal walks");
    }
}
class Dog extends Mammal {
    Dog() {
        System.out.println("Dog created");
    }
    void bark() {
        System.out.println("Dog barks");
    }
}
class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        d.eat();
        d.walk();
        d.bark();
    }
}
```


### Step-by-Step

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Dog object creation | Triggers constructors: Animal → Mammal → Dog |
| 2 | Animal constructor output | "Animal created" printed |
| 3 | Mammal constructor output | "Mammal created" printed |
| 4 | Dog constructor output | "Dog created" printed |
| 5 | eat() called | Inherited from Animal |
| 6 | walk() called | Inherited from Mammal |
| 7 | bark() called | Defined in Dog |

**Visual Representation:**

```
Heap:
  Dog Object
  -------------
  Animal fields (top ancestor)
  Mammal fields (intermediate)
  Dog fields (bottom child)
  -------------
```

- Each layer inherits and builds upon the previous.

***

## Hierarchical Inheritance

Hierarchical inheritance sees one parent class with multiple subclasses, each adding different features.

### Why hierarchical inheritance?

- Maximizes code reuse for related classes.
- Models branching hierarchies (one base, many specialized children).

**Expanded Example:**

```java
class Shape {
    Shape() {
        System.out.println("Shape created");
    }
    void draw() {
        System.out.println("Drawing a shape");
    }
}
class Circle extends Shape {
    Circle() {
        System.out.println("Circle created");
    }
    void area() {
        System.out.println("Area of circle computed");
    }
}
class Square extends Shape {
    Square() {
        System.out.println("Square created");
    }
    void area() {
        System.out.println("Area of square computed");
    }
}
class Test {
    public static void main(String[] args) {
        Circle c = new Circle();
        c.draw();
        c.area();
        Square s = new Square();
        s.draw();
        s.area();
    }
}
```


### Step-by-Step

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Circle object creation | Shape constructor, then Circle constructor runs |
| 2 | draw() called | Shared method from Shape |
| 3 | area() called (Circle) | Specialized method from Circle |
| 4 | Square object creation | Shape constructor, then Square constructor runs |
| 5 | draw() called | Shared method from Shape |
| 6 | area() called (Square) | Specialized method from Square |

**Visual Representation:**

```
         Shape
        /     \
   Circle    Square
```

- All subclasses access common parent fields and methods.

***

## Multiple Inheritance — Why Not Possible in Java?

Multiple inheritance occurs when a class inherits from more than one parent class. Java intentionally forbids this at the class level because it creates ambiguity and complex compiler challenges, the most famous of which is the "Diamond Problem."

### What is the Diamond Problem?

The Diamond Problem arises when:

- A single class tries to inherit from two parent classes.
- Both parents inherit from a common ancestor and implement (override) the same method.
- If the child class calls the method, which parent's implementation should run?

**Diamond Problem Diagram:**

```
    A
   / \
  B   C
   \ /
    D
```

- Class D inherits from both B and C, each having their own version of a method from A.
- If D calls that method, the compiler cannot decide whether to use B’s or C’s version. This ambiguity is known as the diamond problem.

**Java Code Attempt (Not Allowed):**

```java
class A {
    void show() { System.out.println("A"); }
}
class B extends A {
    void show() { System.out.println("B"); }
}
class C extends A {
    void show() { System.out.println("C"); }
}
// This will cause a compile error!
class D extends B, C { }
```

- Java’s compiler prevents this scenario.


### Why Java Forbids Multiple Inheritance of Classes

- Prevents ambiguous situations like the diamond problem.
- Keeps method resolution safe and straightforward.
- Encourages composition and interface-based design for flexibility.
- Simplifies code maintainability and reduces bugs in large systems.

**Summary Table: Why Multiple Inheritance Is Disallowed**


| Reason | Description |
| :-- | :-- |
| Ambiguous method resolution | Compiler cannot choose parent method when conflict |
| Complex hierarchy management | Confusing subclass relationships lead to maintainability issues |
| Diamond problem | See diagram above—method conflict, ambiguity |


***

## Hybrid Inheritance

Hybrid inheritance combines several inheritance types in one design. This can mean a subclass participates in both hierarchical and multilevel inheritance patterns within an object graph.

### Why hybrid inheritance?

- Lets developers craft complex hierarchies suited to nuanced domain logic.
- Promotes code reuse across several dimensions.
- Restricted in Java to patterns that do not trigger multiple inheritance ambiguity.

**Expanded Example:**

```java
class A {
    void display() { System.out.println("A"); }
}
class B extends A {
    void display() { System.out.println("B"); }
}
class C extends A {
    void display() { System.out.println("C"); }
}
class D extends B { // D cannot extend both B and C in Java!
    void display() { System.out.println("D"); }
}
```

- D can extend B—making a multilevel chain—but cannot extend both B and C.

**Visual Representation:**

```
      A
     / \
    B   C
    |
    D
```

- Hybrid structures are confined to single chains (no direct multiple class inheritance).

***

## Summary Table for Types of Inheritance

| Type | Description | Code Structure/Example |
| :-- | :-- | :-- |
| Single | One direct parent | `class B extends A` |
| Multilevel | Chain of inheritance | `class C extends B extends A` |
| Hierarchical | Multiple classes extend single parent | `class B extends A`, `class C extends A` |
| Multiple | **Not supported** for classes in Java | Compile error |
| Hybrid | Combination (within allowed chains) | Restricted in Java |


***

## Additional Insights

- Java’s single inheritance model prevents subtle, hard-to-trace bugs and ambiguous hierarchies.
- The diamond problem is central to Java’s decision to ban multiple inheritance in classes.
- Hybrid patterns are possible only where there are no conflicts or ambiguities.
- Developers aiming for multiple inheritance effects should use interfaces cautiously and resolve any ambiguities explicitly.

***

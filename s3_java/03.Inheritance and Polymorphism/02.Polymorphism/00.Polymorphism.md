# Polymorphism in Java

Polymorphism is a cornerstone of object-oriented programming (OOP) in Java. It enables objects to behave differently based on their runtime type—even when they share the same interface or superclass. The word “polymorphism” comes from the Greek roots “poly” (many) and “morph” (form), precisely capturing its essence: **one entity, many forms**.

***

## What is Polymorphism?

Polymorphism allows the same method or object to appear and operate in multiple forms. It underlies many OOP behaviors, improving flexibility, maintainability, and code reuse.

**Key Concepts:**

- **Single Interface, Multiple Methods:** The same method or action has different implementations.
- **Run-Time vs Compile-Time:** The decision of which implementation to invoke can happen at either compile time or runtime.

***

### Why Use Polymorphism?

- **Code Maintainability:** Reduces duplication by centralizing logic and letting subclasses provide variations.
- **Flexibility:** Enables new classes to work with existing code seamlessly.
- **Abstraction and Interface Use:** Decouples code from specific classes—useful for building frameworks and APIs.
- **Real-World Modeling:** Mirrors situations where a single action takes on different forms depending on context (e.g., “draw” for shapes).

***

## Types of Polymorphism in Java

Java supports two main kinds of polymorphism:

### 1. Compile-Time Polymorphism (Static Polymorphism)

**Definition:** The method to be executed is determined at compile time. This typically occurs through **method overloading**.

- **Method Overloading:** Multiple methods with the same name but different parameter lists within the same class.

**Example:**

```java
class MathUtil {
    // Method 1: adds integers
    int add(int a, int b) {
        return a + b;
    }
    // Method 2: adds doubles
    double add(double a, double b) {
        return a + b;
    }
}

class Test {
    public static void main(String[] args) {
        MathUtil calc = new MathUtil();
        System.out.println(calc.add(2, 3));      // Calls int-version: 5
        System.out.println(calc.add(2.5, 3.5));  // Calls double-version: 6.0
    }
}
```


#### Why Use Method Overloading?

- Provides concise method names.
- Improves code readability and maintainability.
- Handles different input scenarios with the same logical operation.

***

### 2. Run-Time Polymorphism (Dynamic Polymorphism)

**Definition:** The method to be executed is determined at runtime, usually via **method overriding** and superclass references.

- **Method Overriding:** Subclass provides its own implementation for a method declared in a superclass.

**Example:**

```java
class Animal {
    void sound() {
        System.out.println("Animal makes a sound");
    }
}
class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}
class Cat extends Animal {
    void sound() {
        System.out.println("Cat meows");
    }
}

class Test {
    public static void main(String[] args) {
        Animal ref;
        ref = new Dog(); ref.sound(); // Prints "Dog barks"
        ref = new Cat(); ref.sound(); // Prints "Cat meows"
    }
}
```


#### Key Features of Runtime Polymorphism

- **Superclass reference, subclass object:** The type of object determines the method executed at runtime.
- **Dynamic method dispatch:** Java chooses the correct method version at runtime.

***

## Real-life Analogy

Imagine a remote control (reference variable) that can operate a TV, an AC, or a projector (different objects). The remote’s "power" button results in different behaviors—a TV switches on, an AC starts cooling, a projector shows an image. The exact behavior is known only at runtime, based on the actual device.

***

## Step-by-Step Explanation with Visual Table

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Declare Animal reference | Holds any object of type Animal or its subtypes |
| 2 | Assign Dog object to Animal reference | Polymorphic assignment |
| 3 | Call sound() | Runs Dog's overridden version |
| 4 | Assign Cat object to same reference | Reference now points to Cat |
| 5 | Call sound() | Runs Cat's overridden version |

**Visual Representation:**

```
Animal ref  -----> Dog Object (sound() overridden) 
        \-----> Cat Object (sound() overridden)
```

- The method called depends on the actual object, not just the variable’s type.

***

## Polymorphic Variables

A polymorphic variable can refer to different types of objects at different points in time, as long as they all share a common superclass or interface.

**Example:**

```java
Animal a;
a = new Dog();   // a refers to a Dog
a = new Cat();   // a refers to a Cat
```

- The same variable `a` can point to objects of multiple types, as long as each is a subclass of Animal.

***

## More Examples: Compile-Time vs Run-Time Polymorphism

| Type | Mechanism | Example |
| :-- | :-- | :-- |
| Compile-Time | Method Overloading | `sum(int, int)`, `sum(double, double)` |
| Run-Time | Method Overriding | `Animal.sound()` overridden in Dog, Cat |


***

## Summary Table: Compile-Time vs Run-Time

| Feature | Compile-Time | Run-Time |
| :-- | :-- | :-- |
| When decided | Compilation | Execution (runtime) |
| Mechanism | Method Overloading | Method Overriding |
| Uses inheritance | Not required | Required |
| Example method call | Selected by argument type/number | Selected by actual object |
| Java keywords used | None special | `@Override`, superclass references |


***

## Additional Insights

- Operator overloading is *not* supported in Java (unlike some other languages) to prevent ambiguity.
- Polymorphism is vital for frameworks, GUIs, and libraries, making them both flexible and extensible.
- It powers design patterns such as Factory, Strategy, and Command patterns, all of which rely on treating objects uniformly while leveraging their differences in behavior.

***

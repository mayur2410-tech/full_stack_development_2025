# Interface in Java

In Java, an **interface** represents a contract that defines a set of abstract behaviors (methods) that implementing classes must provide. Interfaces enable full abstraction, allowing the separation of *what* a class should do from *how* it does it.

***

## What is an Interface?

An interface is a special reference type in Java, similar to a class, but:

- It only declares method signatures (abstract methods) - no method bodies (before Java 8).
- From Java 8 onward, interfaces can include **default** and **static** methods with implementations.
- Variables declared in interfaces are implicitly `public static final` (constants).
- Interfaces cannot be instantiated but can be implemented by classes.

***

### Why Use Interfaces?

- To define a **contract or capability** that multiple classes can implement, regardless of their place in the class hierarchy.
- To achieve **full abstraction** â€” no method implementation is enforced unless default or static.
- To enable **multiple inheritance of type**, since a class can implement many interfaces.
- To facilitate **loose coupling** and improve **flexibility** of code.
- Essential in **design patterns** and API designs.

***

## Declaring and Implementing an Interface

### Interface Declaration Syntax

```java
public interface InterfaceName {
    // Abstract method
    void method1();

    // Default method with body (since Java 8)
    default void method2() {
        System.out.println("Default implementation");
    }

    // Static method with body (since Java 8)
    static void method3() {
        System.out.println("Static method in Interface");
    }
}
```


### Implementing an Interface in a Class

```java
class ClassName implements InterfaceName {
    @Override
    public void method1() {
        System.out.println("Implemented method1");
    }
}
```


***

## Full Example: Interface with Abstract, Default, and Static Methods

```java
interface Vehicle {
    // Abstract method (must be implemented)
    void drive();

    // Default method (optional to override)
    default void start() {
        System.out.println("Vehicle starts");
    }

    // Static method (cannot be overridden)
    static void info() {
        System.out.println("Vehicle interface - static method");
    }
}

class Car implements Vehicle {
    @Override
    public void drive() {
        System.out.println("Car is driving");
    }

    // Overriding default method
    @Override
    public void start() {
        System.out.println("Car starts with key");
    }
}

public class Test {
    public static void main(String[] args) {
        Vehicle.info();  // Call static method on interface

        Car car = new Car();
        car.start();     // Calls overridden start method
        car.drive();     // Calls implemented drive method
    }
}
```

**Output:**

```
Vehicle interface - static method
Car starts with key
Car is driving
```


***

## Step-by-Step Explanation

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Declare `Vehicle` interface | Abstract method `drive()`, default method `start()`, static `info()` |
| 2 | Implement interface in `Car` | Must implement abstract `drive()`, optionally override default `start()` |
| 3 | Call static method | `Vehicle.info()` accessed by interface name directly |
| 4 | Create `Car` instance | Can invoke overridden `start()` and implemented `drive()` |


***

## Characteristics and Rules of Interfaces

- **Abstract Methods:** All methods without bodies are implicitly `public` and `abstract`.
- **Default Methods:** Introduced in Java 8, have a body, and enable extending interfaces without breaking existing implementations.
- **Static Methods:** Belong to the interface class itself, cannot be overridden by implementing classes.
- **Variables:** Are implicitly `public static final` (constants).
- **Constructors:** Interfaces **cannot** have constructors.
- **Multiple Implementation:** Classes may implement multiple interfaces.
- **Access Modifiers:** Methods are always `public`.
- **Inheritance:** Interfaces can extend multiple interfaces.

***

## The Diamond Problem and Default Methods

Since Java allows multiple inheritance of interfaces, **default methods** can cause conflicts if two interfaces provide the same default method signature. In such cases, the implementing class **must override** the method and provide its own implementation, explicitly resolving the conflict.

**Example:**

```java
interface A {
    default void show() {
        System.out.println("Interface A");
    }
}

interface B {
    default void show() {
        System.out.println("Interface B");
    }
}

class C implements A, B {
    @Override
    public void show() {
        // Must resolve the conflict explicitly
        A.super.show();  // Choose one or combine
        // Or provide new implementation
    }
}
```


***

## Multiple Inheritance Using Interfaces

Java does **not** support multiple inheritance of classes but allows a class to implement multiple interfaces, facilitating multiple inheritance of types.

```java
interface Printable {
    void print();
}

interface Showable {
    void show();
}

class Multi implements Printable, Showable {
    public void print() {
        System.out.println("Printing...");
    }

    public void show() {
        System.out.println("Showing...");
    }
}

public class Test {
    public static void main(String[] args) {
        Multi obj = new Multi();
        obj.print();
        obj.show();
    }
}
```


***

## Summary Table: Java Interface Key Points

| Feature | Description |
| :-- | :-- |
| Methods | Abstract (default `public abstract`), default, static |
| Variables | Implicitly `public static final` (constants) |
| Constructor | Not allowed |
| Multiple Inheritance | Allowed (a class can implement many interfaces) |
| Method Implementation | Classes must implement abstract methods, may override default methods |
| Static Methods | Belong to interface; cannot be overridden |
| Default Methods | Provide default implementation; can be overridden |
| Purpose | Define capabilities/contracts independent of class hierarchy |


***

## Additional Insights

- Default methods solve the **issue of interface evolution** by adding new functionality without breaking existing code.
- Static methods in interfaces act like utility/helper methods related to the interface.
- Interfaces enable designing **flexible APIs**, **decoupled architectures**, and support **polymorphism** elegantly.
- Using interfaces increases **testability**, **code organization**, and **extensibility**.

***
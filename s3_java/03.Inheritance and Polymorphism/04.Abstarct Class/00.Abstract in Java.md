# Abstract Class (Abstraction) in Java

Abstraction is a key principle of object-oriented programming that lets developers **hide internal details** and expose only relevant features of an object. In Java, abstraction is primarily implemented using **abstract classes**.

***

## What is an Abstract Class?

An **abstract class** is a class that cannot be instantiated directly but serves as a **template** for subclasses. It may contain:

- Abstract methods: method declarations without bodies (no implementation).
- Concrete methods: methods with full implementation.
- Fields (variables).
- Constructors.

It is declared using the `abstract` keyword. Abstract classes define **common behavior** and **must be extended** by subclasses which provide implementations for the abstract methods.

***

### Why Use Abstract Classes?

- To **enforce a contract** for subclasses: they guarantee subclasses will implement essential methods.
- To **share common code** among related classes with both abstract and concrete methods.
- To enable **partial abstraction** allowing incomplete classes with some ready features.
- To stop direct creation of objects when instantiation doesn’t make sense logically.
- To support **polymorphism** where a superclass reference can point to subclass objects.

***

## Declaration and Features

- Abstract classes use the `abstract` keyword before `class`.
- If a class has **one or more abstract methods**, it must be declared abstract.
- Abstract methods are declared with the `abstract` keyword and **do not have a method body**.
- You **cannot instantiate** an abstract class directly.
- Subclasses must override all abstract methods unless they are abstract themselves.
- Abstract classes can have fields, constructors, and non-abstract methods.
- Can also contain `static` and `final` methods (though not abstract).

***

## Basic Example of Abstract Class and Methods

```java
abstract class Animal {
    public abstract void makeSound();  // Abstract method

    public void sleep() {              // Concrete method with implementation
        System.out.println("Sleeping...");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Bark bark");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.makeSound();  // Outputs: Bark bark
        dog.sleep();      // Outputs: Sleeping...
    }
}
```


***

### Step-by-Step Explanation

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Declare abstract class `Animal` | Contains abstract and concrete methods |
| 2 | Subclass `Dog` extends `Animal` | Provides implementation of abstract method `makeSound` |
| 3 | Instantiate `Dog` | Objects of subclass can be created, but not of abstract class |
| 4 | Call methods | Abstract method calls subclass version; concrete method inherited |


***

## Detailed Example: Abstract Class with Fields and Constructors

Abstract classes can have constructors and fields to initialize shared state.

```java
abstract class Vehicle {
    private String brand;

    // Constructor to initialize fields
    public Vehicle(String brand) {
        this.brand = brand;
        System.out.println("Vehicle created: " + brand);
    }

    // Abstract method to be implemented by subclasses
    public abstract void move();

    // Concrete method
    public void stop() {
        System.out.println("Vehicle stopped.");
    }

    public String getBrand() {
        return brand;
    }
}

class Car extends Vehicle {
    public Car(String brand) {
        super(brand);
    }

    @Override
    public void move() {
        System.out.println(getBrand() + " car is moving.");
    }
}

public class Test {
    public static void main(String[] args) {
        Car car = new Car("Toyota");
        car.move();
        car.stop();
    }
}
```

**Output:**

```
Vehicle created: Toyota
Toyota car is moving.
Vehicle stopped.
```


***

## Important Aspects to Remember

- **Subclasses must implement all abstract methods** or be declared abstract themselves.
- You can have an abstract class without any abstract methods — just to avoid direct instantiation and share common code.
- Abstract classes support **constructor chaining** through `super()` to initialize common state.
- Abstract methods cannot be `final` or `static`.
- Abstract classes can be used as **reference types** for polymorphism:

```java
Animal a = new Dog();
a.makeSound();
```


***

## Multi-Level Abstract Class Example

A subclass may itself be abstract if it doesn’t implement all inherited abstract methods. Then its subclass must implement them.

```java
abstract class Parent {
    abstract void method1();
    abstract void method2();
}

abstract class Child extends Parent {
    @Override
    void method1() {
        System.out.println("Method1 implemented");
    }
    // method2 not implemented, so Child must be abstract
}

class Grandchild extends Child {
    @Override
    void method2() {
        System.out.println("Method2 implemented");
    }
}

public class Main {
    public static void main(String[] args) {
        Grandchild gc = new Grandchild();
        gc.method1();
        gc.method2();
    }
}
```

**Output:**

```
Method1 implemented
Method2 implemented
```


***

## Summary Table: Abstract Class Syntax and Features

| Feature | Description | Example |
| :-- | :-- | :-- |
| Abstract class declaration | Uses `abstract` keyword before class name | `abstract class Animal { ... }` |
| Abstract method declaration | Methods without body, `abstract` keyword required | `abstract void makeSound();` |
| Instantiation | Cannot instantiate abstract classes directly | `new Animal(); // compile error` |
| Subclasses | Must implement all abstract methods (or be abstract) | `class Dog extends Animal { ... }` |
| Concrete methods allowed | Can contain implemented methods | `void sleep() { ... }` |
| Fields and constructors | Can contain fields and constructors | `public Vehicle(String brand) { ... }` |
| Polymorphism | Abstract type can be used as reference | `Animal a = new Dog();` |
| Use case | Partial abstraction, shared base functionality | Enforce method implementation, reuse code |


***

## Additional Insights

- Abstract classes are the preferred choice when you want to share code among closely related classes with some common behavior.
- They encourage **design by contract**—enforcing a set of rules subclasses must follow.
- Abstract classes help manage complexity by **hiding implementation details**, presenting a clear interface to users.
- The interplay between abstract classes, inheritance, and polymorphism offers powerful tools for a clean, scalable OOP design.

***
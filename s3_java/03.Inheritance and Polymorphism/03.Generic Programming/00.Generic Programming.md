# Generic Programming in Java

Generic programming is a paradigm enabling classes, interfaces, and methods to operate on data types specified only at the time of use. This pattern enhances **code reusability**, **type safety**, and **expressiveness** without duplication or unsafe casting.

***

## What is Generic Programming?

Generics allow the definition of algorithms and data structures with **placeholder types** that are replaced by concrete types at compile-time, ensuring safety without losing flexibility.

Java Generics were introduced in JDK 5 to overcome limitations of handling raw `Object` typesâ€”eliminating the risk of `ClassCastException` at runtime by enforcing type correctness at compile time.

***

### Why Use Generics?

- **Eliminate Explicit Casting:** No need to cast objects when retrieving them from collections.
- **Stronger Type Checks:** Compile-time verification prevents insertion of incompatible types.
- **Improved Code Reusability:** One generic definition works with multiple types.
- **Better Code Readability:** Parameterized types declare the intent clearly.
- **Backward Compatible:** Compiled code works with legacy raw types through type erasure.

***

## Generic Classes

A generic class declares one or more type parameters enclosed in angle brackets (`<>`). These parameters act as placeholders inside the class definition.

### Syntax

```java
class ClassName<T> {
    private T obj;

    ClassName(T obj) {
        this.obj = obj;
    }

    public T getObject() {
        return this.obj;
    }
}
```

- `T` is a conventional placeholder name for "Type".
- Multiple parameters can be declared: `class Pair<T, U> { ... }`.

***

### Example: Generic Class Usage

```java
class Box<T> {
    private T value;

    void set(T value) {
        this.value = value;
    }

    T get() {
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        Box<Integer> integerBox = new Box<>();
        integerBox.set(123);
        System.out.println("Integer Value: " + integerBox.get());

        Box<String> stringBox = new Box<>();
        stringBox.set("Generics in Java");
        System.out.println("String Value: " + stringBox.get());
    }
}
```

**Output:**

```
Integer Value: 123
String Value: Generics in Java
```


***

### Step-by-Step Explanation

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Create `Box<Integer>` | `T` is replaced by `Integer`, enforcing type safety. |
| 2 | Set integer value | Accepts only `Integer` compatible values. |
| 3 | Get integer value | Returns `Integer` directly, no casting required. |
| 4 | Create `Box<String>` | `T` replaced by `String`, separate instance. |
| 5 | Set string value | Accepts only `String`. |
| 6 | Get string value | Returns `String` transparently. |


***

## Generic Classes with Multiple Type Parameters

Multiple type parameters are comma-separated inside `< >` and can be used to define classes supporting several types simultaneously.

### Example

```java
class Pair<T, U> {
    private T first;
    private U second;

    Pair(T first, U second) {
        this.first = first;
        this.second = second;
    }

    void display() {
        System.out.println("First: " + first);
        System.out.println("Second: " + second);
    }
}

public class Main {
    public static void main(String[] args) {
        Pair<String, Integer> pair = new Pair<>("Age", 30);
        pair.display();
    }
}
```

**Output:**

```
First: Age
Second: 30
```


***

## Generic Methods

Generics can be applied to methods independently of classes or interfaces. This allows methods to operate on multiple types without being bound to a generic class.

### Syntax

```java
public <T> void methodName(T param) {
    // method body
}
```

- The type parameter `<T>` is declared before the return type.
- Generic parameters can be more than one: `<T, U, V>`.

***

### Example: Generic Method to Print Arrays

```java
class Utility {
    public static <T> void printArray(T[] array) {
        for (T element : array) {
            System.out.print(element + " ");
        }
        System.out.println();
    }
}

public class Main {
    public static void main(String[] args) {
        Integer[] intArray = {1, 2, 3, 4};
        String[] strArray = {"A", "B", "C", "D"};

        Utility.printArray(intArray);
        Utility.printArray(strArray);
    }
}
```

**Output:**

```
1 2 3 4 
A B C D 
```


***

### Step Analysis

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Call generic method | `<T>` inferred from argument type (Integer[]). |
| 2 | Print ints | Prints all Integer elements. |
| 3 | Call generic method | `<T>` inferred from argument type (String[]). |
| 4 | Print strings | Prints all String elements. |


***

## Bounded Type Parameters

Java generics can restrict type parameters using bounds (`extends`) to allow only types that are subtypes of a particular class or interface.

### Syntax

```java
class ClassName<T extends Number> {
    // T is limited to Number or its subclasses
}
```


***

### Example: Bounded Generic Class

```java
class NumericBox<T extends Number> {
    private T num;

    NumericBox(T num) {
        this.num = num;
    }

    double doubleValue() {
        return num.doubleValue();
    }
}

public class Main {
    public static void main(String[] args) {
        NumericBox<Integer> intBox = new NumericBox<>(10);
        NumericBox<Double> doubleBox = new NumericBox<>(20.5);
        System.out.println(intBox.doubleValue());
        System.out.println(doubleBox.doubleValue());
    }
}
```

**Output:**

```
10.0
20.5
```


***

# Wildcards in Generics in Java

Wildcards in Java generics are special symbols (`?`) used to represent an **unknown type**. They allow you to write flexible and reusable code when you don't know the exact generic type a method or variable should accept. Wildcards provide a way to relax restrictions and broaden the use of generics while preserving type safety.

***

## What is a Wildcard?

The wildcard character `?` is a placeholder for an unknown type in a generic declaration. Wildcards enable more generic methods and classes by allowing you to work with a family of types rather than a single concrete type.

***

### Why Use Wildcards?

- Write methods and classes that work with different generic types.
- Increase flexibility and reusability without compromising compile-time type checks.
- Express variance (covariance and contravariance) in generic APIs.
- Avoid unnecessarily restricting the types accepted beyond what is necessary.

***

## Types of Wildcards in Java

There are three main types of wildcards:

### 1. Unbounded Wildcards (`<?>`)

This wildcard matches any type. It is used when you want to accept a generic type of **any** parameter without restriction.

**Example:**

```java
List<?> list = new ArrayList<String>();
```

- Accepts `List` of any type.
- Useful for read-only access, since adding elements is restricted (except adding `null`).

***

### 2. Upper Bounded Wildcards (`<? extends Type>`)

An upper bounded wildcard restricts the unknown type to be **Type** or any subclass of `Type`.

#### Syntax:

```java
List<? extends Number>
```

- Represents a list of objects of some subtype of `Number` (e.g., `Integer`, `Double`).
- Allows safe **reading** from the list (you know elements are at least `Number`).
- Restricts adding anything except `null` to the list.

***

#### Example of Upper Bounded Wildcard

```java
import java.util.Arrays;
import java.util.List;

class WildcardDemo {
    public static void main(String[] args) {
        List<Integer> intList = Arrays.asList(1, 2, 3);
        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.3);

        System.out.println("Sum of integers: " + sum(intList));
        System.out.println("Sum of doubles: " + sum(doubleList));
    }

    private static double sum(List<? extends Number> list) {
        double total = 0;
        for (Number n : list) {
            total += n.doubleValue();
        }
        return total;
    }
}
```

**Output:**

```
Sum of integers: 6.0
Sum of doubles: 6.6
```


***

### Step-by-Step Explanation for Upper Bounded Wildcard

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Create `List<Integer>` | `intList` holds Integers |
| 2 | Create `List<Double>` | `doubleList` holds Doubles |
| 3 | Pass both lists to `sum()` | Accepts any list whose type extends Number |
| 4 | Method reads elements | Safe reading as `Number` superclass known |


***

### 3. Lower Bounded Wildcards (`<? super Type>`)

A lower bounded wildcard restricts the unknown type to be **Type** or any superclass of `Type`.

#### Syntax:

```java
List<? super Integer>
```

- Accepts `List` of `Integer`, `Number`, or `Object`.
- Useful when you want to **write/add** elements safely.
- Reading from such list returns `Object` type to ensure safety.

***

#### Example of Lower Bounded Wildcard

```java
import java.util.Arrays;
import java.util.List;

class WildcardDemo {
    public static void main(String[] args) {
        List<Integer> intList = Arrays.asList(1, 2, 3);
        List<Number> numberList = Arrays.asList(1, 2, 3);

        printList(intList);
        printList(numberList);
    }

    public static void printList(List<? super Integer> list) {
        for (Object obj : list) {
            System.out.println(obj);
        }
    }
}
```

**Output:**

```
1
2
3
1
2
3
```


***

### Step-by-Step Explanation for Lower Bounded Wildcard

| Step | Action | Explanation |
| :-- | :-- | :-- |
| 1 | Pass `List<Integer>` | Acceptable as `Integer` is same type |
| 2 | Pass `List<Number>` | Acceptable because `Number` is superclass |
| 3 | Method reads using `Object` | Can only safely assume elements are Objects |


***

## Important Notes on Using Wildcards

- **GET and PUT Principle:** Use upper bounded wildcards (`extends`) when retrieving data ("reading" or getting). Use lower bounded wildcards (`super`) when inserting data ("writing" or putting).
- Wildcards improve API flexibility but can complicate type relationships if overused.
- You cannot specify both upper and lower bounds simultaneously on a wildcard (no `<? extends A super B>`).
- Wildcards are used **at use-site** (e.g., in method parameters), unlike type parameters which appear at declaration.

***

## Summary Table: Types of Wildcards

| Wildcard Type | Syntax | Use Case | Allows Reading | Allows Writing |
| :-- | :-- | :-- | :-- | :-- |
| Unbounded | `<?>` | Any type | Yes (as `Object`) | No, except `null` |
| Upper Bounded | `<? extends Type>` | Subtypes of `Type` | Yes (guaranteed type) | No, except `null` |
| Lower Bounded | `<? super Type>` | Supertypes of `Type` | Limited (`Object`) | Yes (safe to write `Type`) |


***

## Additional Insights

- Wildcards simplify working with collections of different but related types.
- When designing APIs, wildcards prevent over-restricting parameter types.
- Understanding when to use `extends` vs `super` is key to safe and expressive generic code.
- Wildcards also impact method overriding and assignment compatibility.

***

# Type Erasure in Java Generics

Type erasure is a core mechanism behind Java's implementation of generics. It allows Java to maintain **backward compatibility** while enforcing type safety **at compile time** â€” by removing generic type information before runtime.

***

## What is Type Erasure?

Type erasure is the **process during compilation where all generic information is removed** (erased) and replaced with the **upper bound of the type parameter** or `Object` if there is no bound.

- The compiled bytecode contains **only ordinary classes, interfaces, and methods** without any generic type parameters.
- This ensures that no new classes or methods are created specifically for each generic instantiation.
- Runtime does not have any information about the generic type parameters.

***

### Why Is Type Erasure Important?

- Maintains **backward compatibility** with older versions of Java and JVMs.
- Ensures **no runtime overhead** for generics â€” generics are only a compile-time feature.
- Avoids complexity in JVM by treating all generic instances as the raw type at runtime.

***

## How Type Erasure Works: Detailed Explanation

### Example 1: Unbounded Type Parameter

Consider a generic class with an unbounded type parameter:

```java
class Box<T> {
    private T obj;

    Box(T obj) {
        this.obj = obj;
    }

    T getObj() {
        return obj;
    }
}
```


***

After compilation (type erasure), the code becomes:

```java
class Box {
    private Object obj;

    Box(Object obj) {
        this.obj = obj;
    }

    Object getObj() {
        return obj;
    }
}
```

- The generic type `T` is replaced by `Object`.
- All references to `T` in fields and methods become `Object`.
- Any assignments or returns involving `T` will require type casting at runtime.

***

### Example 2: Bounded Type Parameter

If the type parameter has an upper bound, the erasure replaces the type by that bound.

```java
class NumberBox<T extends Number> {
    private T num;

    NumberBox(T num) {
        this.num = num;
    }

    T getNum() {
        return num;
    }
}
```


***

After compilation:

```java
class NumberBox {
    private Number num;

    NumberBox(Number num) {
        this.num = num;
    }

    Number getNum() {
        return num;
    }
}
```

- `T` is replaced by `Number` (its upper bound).
- This keeps type safety while using a specific superclass instead of `Object`.

***

## Effects of Type Erasure on Generics

### 1. No Runtime Type Information for Generics

- Generic types are erased, so at runtime the JVM sees raw types.
- **You cannot use `instanceof` with generic types.** For example:

```java
if (obj instanceof T) { } // Compile-time error
```


### 2. No Method Overloading by Generic Type Parameters

- Methods differing only in generic parameter types cause compilation errors after erasure because their signatures become identical.

```java
<T> void method(List<T> list) {}
<U> void method(List<U> list) {} // Compile error after erasure
```


### 3. Type Casts Are Inserted by the Compiler

- To preserve type safety, the compiler inserts casts when retrieving generic values.
- This can lead to `ClassCastException` if unsafe raw types are used or unchecked casts happen.


### 4. Raw Types

- The older pre-generics code (raw types) still works but lacks type safety.
- Mixing generics and raw types can produce warnings and potential runtime exceptions.

***

## Step-by-Step Summary: Type Erasure Process

| Step | Description | Result |
| :-- | :-- | :-- |
| 1 | Detect generic type parameters in code | For example, `T` in `Box<T>` |
| 2 | Replace with upper bound or `Object` | `T` becomes `Object` if unbounded, or first bound if bounded |
| 3 | Erase type info throughout class/method signatures and fields | Remove all generic metadata for runtime |
| 4 | Insert casts where needed for type safety | E.g., cast return values during method calls |
| 5 | Compile to bytecode without generics | Runtime unaware of generic parameters |


***

## Summary Table: Type Erasure Consequences

| Aspect | Description |
| :-- | :-- |
| Type information at runtime | None; generics erased to raw types |
| Type safety | Enforced at compile time by compiler |
| Cast insertion | Compiler inserts casts to ensure safety |
| Runtime checks | Cannot do generic `instanceof` or reflection involving generics |
| Method overloading | Cannot overload methods differing only by generic types |
| Compatibility | Supports legacy code without generics |


***

## Additional Insights

- Type erasure can cause some confusing errors or require careful design, especially when working with reflection or advanced generics features.
- `ClassCastException` at runtime generally indicates misuse of raw types or unchecked type conversions.
- The Java compiler generates **bridge methods** under the hood to maintain polymorphism in generic classes.
- Understanding type erasure is critical for mastering Java generics and their limitations.

***
## Summary Table: Generics Concepts at a Glance

| Concept | Description | Example Use |
| :-- | :-- | :-- |
| Generic Class | Class with parameterized types | `class Box<T> {...}` |
| Generic Method | Method with independent type parameters | `public <T> void method(T t)` |
| Multiple Type Parameters | Supporting multiple type variables | `class Pair<T, U> {...}` |
| Bounded Types | Restricting type parameters with subclass or interface bounds | `class NumericBox<T extends Number>` |
| Wildcards | Flexible use of unknown types | `List<? extends Number>` |
| Type Erasure | Removal of type info post-compilation | Runtime no generic info present |


***

## Additional Insights

- Generics are most commonly used with Java Collections (`List<T>`, `Map<K,V>`, etc.).
- Always prefer **generic types over raw types** for safer code.
- Wildcards help when you want to accept generic types but donâ€™t want to fix exact parameter type.
- Advanced topics include **generic interfaces**, **recursive type bounds**, and **generic constructors** for further type-safe abstractions.

***
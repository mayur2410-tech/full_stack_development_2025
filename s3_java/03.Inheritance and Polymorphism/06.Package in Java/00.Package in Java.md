# Package in Java

A **package** in Java is a namespace that organizes a set of related classes, interfaces, and sub-packages. Conceptually, it is similar to folders on your computer where related files are grouped together.

***

## What is a Package?

- A package is a **grouping mechanism** that helps avoid name conflicts between classes, makes it easier to locate and use classes, and controls access to classes and members.
- Packages **help manage a large codebase** by organizing classes into logical units.
- A Java package corresponds to **a directory structure** in the file system.

***

## Why Use Packages?

- **Avoid class name conflicts:** Two different packages can have classes with the same name, but these classes do not interfere with each other.
- **Encapsulation:** Packages control accessibility. Classes with default (package-private) access are visible only within the same package.
- **Maintainability and Reusability:** Packages organize code logically, making it easy to locate, modify, and reuse.
- **Namespace management:** Instead of all classes in a project in one huge namespace, they are separated by packages for clarity.

***

## How to Declare a Package?

The package declaration must be the **first statement** in a source file (except comments).

Syntax:

```java
package packageName.subPackageName;
```

Example:

```java
package com.example.utilities;
```

- This tells the compiler and JVM that the class belongs to the **com.example.utilities** package.
- Packages are usually named in **all lowercase** to avoid conflicts with class names.
- Sub-packages can be created by extending the package name separated by dots.

***

## Creating and Using Packages: Step-by-Step

### Step 1: Directory Structure and Files

Suppose you want to create a package `mypack`. Create a folder `mypack` and place your Java source files inside it.

```
├── mypack
│   └── MyClass.java
```


***

### Step 2: Write the Package Statement in the Source File

```java
package mypack;

public class MyClass {
    public static void printMessage() {
        System.out.println("Hello from mypack.MyClass");
    }
}
```


***

### Step 3: Compile and Generate Package Directory Structure

Compile the class using the `-d` option to specify the destination root directory.

```bash
javac -d . MyClass.java
```

- The compiler creates the package directories and places the `.class` files accordingly.

***

### Step 4: Use Package Classes in Another Class

```java
import mypack.MyClass;

public class Test {
    public static void main(String[] args) {
        MyClass.printMessage();
    }
}
```

- The `import` statement allows direct use of the `MyClass` without fully qualifying its name.

***

### Step 5: Compile and Run

- Compile the Test class with access to the packages.

```bash
javac Test.java
```

- Run the `Test` class:

```bash
java Test
```


***

## Fully Qualified Class Name

- When you do **not** use the `import` statement, you can access a class by its **fully qualified name**:

```java
public class Test {
    public static void main(String[] args) {
        mypack.MyClass.printMessage();
    }
}
```


***

## Default Package

- If you **do not specify any package**, the class belongs to the **default package**.
- Classes in the default package **cannot be imported** by classes outside the package.
- It is good practice to use explicit packages to avoid naming conflicts and improve code organization.

***

## Package Naming Conventions

- Use your organization’s **Internet domain name in reverse** as the root of the package.
- Subsequent parts specify features, modules, or subpackages.
- Example:

```
com.example.project.module
```

- Follow **lowercase naming**.
- Avoid special characters; use only letters and numbers.

***

## Access Control in Packages

- **Public members** are accessible from any other class.
- **Protected members** are accessible within the same package and subclasses.
- **Default (package-private) members** — no explicit modifier — are accessible only within the package.
- **Private members** are accessible only within the class.

***

## Nested Packages

- Packages can contain **sub-packages**, following a logical directory hierarchy.
- Sub-packages are independent; `com.example` and `com.example.utils` have no special relationship in access control.

***

## Classpath and Packages

The JVM and compiler look for class files based on the **classpath**, which is a set of directories or JAR files.

- You can specify the classpath with `-cp` or `-classpath` option.
- The classpath root contains the folder(s) corresponding to package names.

Example of running with classpath:

```bash
java -cp . com.example.project.MyClass
```


***

## Example of Organized Package Structure

```
src
├── com
│   └── example
│       ├── utils
│       │   └── Utility.class
│       └── app
│           └── MainApp.class
```

- The source root `src` contains `com.example.utils` and `com.example.app` packages.

***

## Summary Table: Java Packages Overview

| Aspect | Description |
| :-- | :-- |
| Purpose | Organize classes \& interfaces |
| Relationship | Groups related types into namespaces |
| Syntax | `package packageName;` at the top of source file |
| Directory Structure | Package names map to directory structures |
| Access Modifiers in Packages | Controls visibility of classes/members |
| Import Statements | Used to bring external packages' types into scope |
| Classpath | JVM and compiler search path for classes |


***

## Additional Insights

- Organizing code into packages **improves maintainability**.
- Proper package structure helps **large projects scale efficiently**.
- Package names aligned with domain names reduce the risk of **name conflicts**.
- IDEs like Eclipse and IntelliJ represent packages as folders visually.
- Always use **lowercase names** and well-planned package hierarchies.

***
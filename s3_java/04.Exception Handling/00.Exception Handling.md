# Exception Handling in Java

Exception handling is a powerful mechanism in Java that enables programs to deal with **runtime errors** or unexpected events gracefully, preventing program crashes and allowing the program to maintain normal flow.

***

## What is Exception Handling?

Exception handling is the process of **detecting, catching, and managing exceptions** (runtime errors) that occur during program execution to maintain normal flow and provide meaningful responses.

- An **exception** is an event that disrupts the normal flow, such as division by zero, file not found, or null pointer access.
- Java provides keywords and structures to handle exceptions effectively: `try`, `catch`, `finally`, `throw`, and `throws`.

***

## Exception Class Hierarchy in Java

All exceptions in Java are represented by objects of classes derived from the base class `java.lang.Throwable`.

### Visual Representation of Exception Hierarchy

```
java.lang.Object
     |
java.lang.Throwable
     |
+-------------------+
|                   |
java.lang.Error    java.lang.Exception
                        |
              +-------------------+
              |                   |
     java.lang.RuntimeException   (Checked exceptions)
          (Unchecked exceptions)
```
### Explanation:

- **Throwable:** Root of all errors and exceptions.
- **Error:** Serious problems not meant to be caught (e.g., `OutOfMemoryError`).
- **Exception:** Represents recoverable conditions.
- **RuntimeException:** Unchecked exceptions (e.g., `NullPointerException`, `ArithmeticException`).
- **Checked Exceptions:** Must be declared or handled (e.g., `IOException`).

***

## 2. Exception Handling Flow (Using `try-catch-finally`)

### Flowchart:

```
               ┌─────────────────────────┐
               │ Start Program Execution │
               └─────────────┬───────────┘
                             |
                      ┌──────▼─────-┐
                      │ Execute try │
                      │ block code  │
                      └─────────────┘
                             |
               ┌─────────────┴─────────────┐
               │                           │
       No Exception                 Exception Thrown
               │                           │
    ┌──────────▼───────┐          ┌────────▼──────────┐
    │ Execute finally  │          │ Find matching     │
    │ block            │          │ catch block       │
    └──────────┬───────┘          └────────┬──────────┘
               │                           │
               │                   Matching catch found?
               │                           │
               │                  ┌────────▼─────────┐
               │                  │ Yes              │
               │                  │ Execute catch    │
               │                  │ block code       │
               │                  └────────┬─────────┘
               │                           │
               │                   Execute finally block
               │                           │
               │                  Program continues or
               │                  propagates exception
               │
               ▼
       Program continues
```


***


### Key Points:

- **Throwable** has two main subclasses:
    - `Error`: Serious problems the application should not try to handle (e.g., `OutOfMemoryError`).
    - `Exception`: Errors that applications can catch and handle.
- **Checked exceptions:** Must be either caught or declared (compile-time checked).
- **Unchecked exceptions (RuntimeException):** May or may not be caught (e.g., `NullPointerException`).

***

## Basic Exception Handling Syntax (`try-catch`)

You place the code which might throw an exception inside a `try` block. Exceptions are caught in one or more associated `catch` blocks.

```java
try {
    // Code that may throw exception
} catch(ExceptionType e) {
    // Handling code
}
```


***

### Practical Example

```java
public class TryCatchExample {
    public static void main(String[] args) {
        try {
            int data = 100 / 0;  // Throws ArithmeticException
        } catch (ArithmeticException e) {
            System.out.println("Cannot divide by zero: " + e.getMessage());
        }
        System.out.println("Rest of the program...");
    }
}
```

**Output:**

```
Cannot divide by zero: / by zero
Rest of the program...
```


***

## Multiple Catch Blocks

Multiple catch blocks allow handling different exceptions separately from the same `try` block.

```java
try {
    // Code that may throw different exceptions
} catch (ArithmeticException e) {
    // Handle arithmetic exceptions
} catch (ArrayIndexOutOfBoundsException e) {
    // Handle array index exceptions
} catch (Exception e) {
    // Handle any other exceptions
}
```


***

### Example of Multiple Catch Blocks

```java
public class MultiCatchExample {
    public static void main(String[] args) {
        try {
            int[] arr = new int[^5];
            arr[^5] = 10;   // Throws ArrayIndexOutOfBoundsException
            int data = 10 / 0;  // Throws ArithmeticException
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Array index error: " + e.getMessage());
        } catch (ArithmeticException e) {
            System.out.println("Arithmetic error: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("General exception: " + e.getMessage());
        }
    }
}
```

**Output:**

```
Array index error: 5
```

- The first exception encountered is handled; subsequent lines in `try` are skipped.

***

## Important: Order of Catch Blocks

- Catch blocks must be ordered from **most specific to most general** exceptions.
- If a superclass exception comes earlier than subclass exceptions, the specific catch blocks become unreachable, causing compile-time errors.

***

## `finally` Block

The `finally` block contains code that **always executes after the `try-catch` blocks**, regardless of whether exceptions were thrown or caught.

- Used for **cleanup actions** like closing files, releasing resources, etc.
- Optional but essential for resource management.

```java
try {
    // risky code
} catch (Exception e) {
    // exception handling
} finally {
    // cleanup code (always executes)
}
```


***

### Example with finally

```java
public class FinallyExample {
    public static void main(String[] args) {
        try {
            int data = 25 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Exception caught: " + e.getMessage());
        } finally {
            System.out.println("Finally block executed");
        }
    }
}
```

**Output:**

```
Exception caught: / by zero
Finally block executed
```


***

## Flow of Exception Handling Execution

1. **Normal execution** proceeds in the `try` block until an exception occurs.
2. Once an exception occurs, the rest of the `try` block is **skipped**.
3. The JVM searches for matching `catch` block to handle the thrown exception.
4. The matched `catch` executes.
5. The `finally` block runs regardless of what happened before (exception or normal flow).
6. If no matching `catch` found, exception is propagated to the caller.

***

## Summary Table: Exception Handling Keywords

| Keyword | Purpose | Notes |
| :-- | :-- | :-- |
| `try` | Blocks code that may throw exceptions | Encloses risky code |
| `catch` | Handles specified exception | Must follow a `try` block |
| `finally` | Executes code regardless of exception occurrence | Used for cleanup |
| `throw` | Manually throw an exception | Used inside method |
| `throws` | Declares exceptions a method can throw | Used in method signature to propagate |


***

## Additional Insights

- Java supports **nested `try-catch` blocks** for granular exception handling.
- Use **checked exceptions** for recoverable errors and **unchecked exceptions** for programming errors.
- Proper exception handling improves **program robustness** and **maintains program flow** even during failures.
- Always clean up resources (`close` files/connections) in `finally` or use try-with-resources (`AutoCloseable`).

***
# Graph Traversals: Depth-First Search (DFS)

## Introduction and Definition

Depth-First Search (DFS) is a recursive graph traversal technique that explores as far along a branch as possible before backtracking, allowing for traversal of all vertices reachable from a starting point. It is commonly used for pathfinding, cycle detection, and discovering connected components.

***
## Step-by-Step Explanation of DFS with Example and Visual Representation

Consider the following directed graph with 5 vertices and edges:

```
Edges:
0 → 1, 0 → 2
1 → 2
2 → 0, 2 → 3
3 → 3
4 (isolated vertex)

Visual Layout:

      0
     / \
    1   2
         \
          3

4 (isolated)
```


### Starting DFS at vertex 2:

1. **Initialization:**
    - Mark all vertices as unvisited: `visited = [false, false, false, false, false]`.
2. **Visit Vertex 2:**
    - Mark vertex 2 as visited and print it.
    - Explore neighbors of 2: vertices 0 and 3.
3. **Visit Vertex 0:**
    - Mark vertex 0 as visited and print it.
    - Explore neighbors of 0: vertices 1 and 2.
    - Vertex 2 is already visited; proceed to vertex 1.
4. **Visit Vertex 1:**
    - Mark vertex 1 as visited and print it.
    - Explore its neighbors: vertex 2 is already visited.
5. **Backtrack to Vertex 2:**
    - Next neighbor is vertex 3.
6. **Visit Vertex 3:**
    - Mark vertex 3 as visited and print it.
    - Vertex 3’s only neighbor is itself (already visited).
7. **End of Traversal:**
    - Nodes 0, 1, 2, and 3 visited.
    - Vertex 4 remains unvisited (isolated).

### DFS traversal order:

**2 0 1 3**

***

## Algorithm Steps and Code Explanation (Step-by-Step)


***

### Step 1: Class and Graph Initialization

```cpp
class Graph {
private:
    int V;                  // Number of vertices
    list<int> *adj;         // Pointer to adjacency list array

public:
    // Constructor to initialize graph with V vertices
    Graph(int vertices) {
        V = vertices;
        adj = new list<int>[V];    // Create adjacency list for each vertex
    }

    // Destructor to free allocated memory
    ~Graph() {
        delete[] adj;
    }
};
```

**Explanation:**

- Declare private members for the number of vertices (`V`) and adjacency list pointer (`adj`).
- Constructor takes number of vertices and initializes an array of adjacency lists.
- Destructor properly deallocates the dynamic array to avoid memory leaks.

***

### Step 2: Method to Add Edges

```cpp
    // Add an edge from u to v (directed graph)
    void addEdge(int u, int v) {
        adj[u].push_back(v);    // Append v to u's adjacency list
    }
```

**Explanation:**

- For a directed graph, add vertex `v` to the adjacency list of `u`.
- If an undirected graph is desired, add the edge in both directions.

***

### Step 3: Recursive DFS Utility Method

```cpp
private:
    void DFSUtil(int v, bool visited[]) {
        visited[v] = true;               // Mark current vertex as visited
        cout << v << " ";                // Output the vertex

        // Visit all adjacent vertices not yet visited
        for (int neighbor : adj[v]) {
            if (!visited[neighbor]) {
                DFSUtil(neighbor, visited);
            }
        }
    }
```

**Explanation:**

- Takes a vertex `v` and the visited array.
- Marks `v` visited and prints it.
- Recursively visits every neighbor of `v` if it hasn't been visited yet.
- This recursive exploration dives deep into one branch before backtracking.

***

### Step 4: Public DFS Method to Initialize Visited Array

```cpp
public:
    void DFS(int startVertex) {
        bool *visited = new bool[V];     // Create visited array
        for (int i = 0; i < V; i++) {
            visited[i] = false;          // Initialize all vertices as unvisited
        }

        DFSUtil(startVertex, visited);    // Call recursive helper starting at startVertex

        delete[] visited;                 // Clean up memory
    }
```

**Explanation:**

- Creates a boolean array `visited` to track visited vertices.
- Initializes all to `false`.
- Calls the recursive helper function with the starting vertex.
- Deletes the allocated memory after traversal completes.

***

## Example Visual Explanation

Consider the graph below with 5 vertices and edges:

```
Edges:
0 → 1, 0 → 2
1 → 2
2 → 0, 2 → 3
3 → 3
4 (isolated node)

Graph layout:

      0
     / \
    1   2
         \
          3
4 (isolated)
```

Starting DFS at vertex 2, the traversal order printed will likely be:

```
2 0 1 3
```

Explanation:

- Start at 2: mark visited and print.
- Move to unvisited neighbor 0, mark visited, print.
- From 0, explore unvisited neighbor 1.
- From 1, no new neighbors; backtrack.
- From 2, next neighbor is 3.
- Node 4 is isolated and remains unexplored unless explicitly started there.

***

## Summary:

- DFS explores graph vertices as deeply as possible before backtracking.
- Uses a visited array to avoid repeated visits and infinite loops from cycles.
- Recursive helper function performs the depth exploration.
- Efficiently implemented with time complexity $O(V + E)$ (vertices + edges).
- Useful for identifying connected components, cycles, and pathfinding.

***

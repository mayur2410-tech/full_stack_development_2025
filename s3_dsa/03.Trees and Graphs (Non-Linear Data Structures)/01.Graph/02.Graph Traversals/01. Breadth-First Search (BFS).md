# Graph Traversals: Breadth-First Search (BFS)

## Introduction and Definition

Breadth-First Search (BFS) is a graph traversal algorithm that explores vertices level by level. It visits all neighboring vertices of a starting vertex before moving on to vertices at the next level. BFS is widely used for finding the shortest path in unweighted graphs, connectivity analysis, and level order traversal.

***

## Step-by-Step Explanation of BFS with Example and Visual Representation

Consider the following directed graph with 5 vertices and edges:

```
Edges:
0 → 1, 0 → 2
1 → 2
2 → 0, 2 → 3
3 → 3
4 (isolated vertex)

Visual Layout:

      0
     / \
    1   2
         \
          3

4 (isolated)
```


### Starting BFS at vertex 2:

1. **Initialization:**
    - Mark all vertices as unvisited: `visited = [false, false, false, false, false]`.
    - Create an empty queue.
    - Mark vertex 2 as visited and enqueue it:
`visited = [false, false, true, false, false]`, `queue = `.
2. **Visit Vertex 2:**
    - Dequeue vertex 2 and process it (print `2`).
    - Check adjacency of 2 (vertices 0 and 3).
    - Mark 0 and 3 as visited and enqueue:
`visited = [true, false, true, true, false]`, `queue = [0, 3]`.
3. **Visit Vertex 0:**
    - Dequeue vertex 0 and process it (print `0`).
    - Check adjacency of 0 (vertices 1 and 2).
    - Vertex 2 is already visited; mark vertex 1 as visited and enqueue:
`visited = [true, true, true, true, false]`, `queue = [3, 1]`.
4. **Visit Vertex 3:**
    - Dequeue vertex 3 and process it (print `3`).
    - Check adjacency of 3 (vertex 3 itself).
    - Already visited, so no new enqueues.
5. **Visit Vertex 1:**
    - Dequeue vertex 1 and process it (print `1`).
    - Check adjacency of 1 (vertex 2).
    - Already visited, so no new enqueues.
6. **Queue empty; BFS complete.**

### BFS traversal order: `2 0 3 1`

- Vertex 4 remains unvisited due to isolation.

***

## Code Implementation and Explanation


***

### Step 1: Class and Graph Initialization

```cpp
class Graph {
private:
    int V;                  // Number of vertices
    list<int> *adj;         // Pointer to adjacency list array

public:
    // Constructor to initialize graph with V vertices
    Graph(int vertices) {
        V = vertices;
        adj = new list<int>[V];    // Create adjacency list for each vertex
    }

    // Destructor to free allocated memory
    ~Graph() {
        delete[] adj;
    }
};
```

**Explanation:**

- Stores the number of vertices `V` and adjacency lists pointer `adj`.
- Constructor initializes arrays for adjacency.
- Destructor frees memory to avoid leaks.

***

### Step 2: Method to Add Edges

```cpp
    // Add an edge from u to v (directed graph)
    void addEdge(int u, int v) {
        adj[u].push_back(v);    // Append v to u's adjacency list
    }
```

**Explanation:**

- Adds directed edge `u → v`.
- For undirected graphs, add in both directions.

***

### Step 3: BFS Traversal Method

```cpp
#include <queue>

public:
    void BFS(int startVertex) {
        bool *visited = new bool[V];  // Visited array
        for (int i = 0; i < V; i++)
            visited[i] = false;       // Initialize all vertices as unvisited

        queue<int> q;                 // Queue for BFS
        visited[startVertex] = true; // Mark start vertex as visited
        q.push(startVertex);          // Enqueue start vertex

        while (!q.empty()) {
            int curr = q.front();     // Get front vertex from queue
            cout << curr << " ";      // Process current vertex (print it)
            q.pop();                  // Remove it from queue

            // Visit all adjacent vertices of current vertex
            for (int neighbor : adj[curr]) {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;  // Mark as visited
                    q.push(neighbor);           // Enqueue for future exploration
                }
            }
        }

        delete[] visited;             // Clean up allocated memory
    }
```

**Explanation:**

- Initializes a `visited` array marking all nodes unvisited.
- Uses a queue to manage exploration order.
- Starts from `startVertex`—marks visited and enqueues it.
- Processes nodes in FIFO order, enqueues neighbors not yet visited.
- Traverses layer by layer until no vertices are left in the queue.

***

## Summary:

- BFS explores graphs level-wise, ensuring all nodes at a given distance are visited before moving deeper.
- It is essential for shortest path algorithms in unweighted graphs and connectivity tests.
- Time complexity is $O(V + E)$, where $V$ is vertices and $E$ is edges.
- Space complexity is $O(V)$ for the queue and visited array.
- The method outputs all reachable nodes from a starting vertex.

***

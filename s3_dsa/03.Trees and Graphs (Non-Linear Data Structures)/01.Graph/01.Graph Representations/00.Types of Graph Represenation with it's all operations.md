# Representation of Graph Data Structure

Graphs can be represented in multiple ways to store and manage vertices and edges efficiently. The two most common representations are:

***

## 1. Adjacency Matrix


***

#### Explanation:

- Uses a **2D matrix** (size $V \times V$) where $V$ is the number of vertices.
- Rows and columns represent vertices.
- The entry at row $i$, column $j$ indicates whether an edge exists between vertex $i$ and vertex $j$.
- For **unweighted graphs**, entries are:
    - `1` if an edge exists,
    - `0` if no edge exists.
- For **weighted graphs**, the matrix stores edge weights instead of 1s and 0s.
- **Space:** Always $O(V^2)$ regardless of the number of edges.
- Fast edge look-up $O(1)$.

***

#### Visual Example:

```
Graph with vertices: A, B, C

Edges:
A -- B
B -- C

Adjacency Matrix:

     A  B  C
   ------------
A |  0  1  0
B |  1  0  1
C |  0  1  0

- Row and column labels represent vertices.
- 1 indicates presence of an edge, 0 indicates absence.
- Matrix is symmetric for undirected graphs.
```


***
## Graph Representation Using Adjacency Matrix in C++

### Step 1: Define the Graph Class and Initialize the Matrix

```cpp
class Graph {
private:
    int V;                // Number of vertices
    int **adjMatrix;       // Pointer to a 2D array for adjacency matrix

public:
    // Constructor to initialize matrix with zeros
    Graph(int vertices) {
        V = vertices;

        // Dynamically allocate memory for a V x V matrix
        adjMatrix = new int*[V];
        for (int i = 0; i < V; i++) {
            adjMatrix[i] = new int[V];
        }

        // Initialize all entries to 0 (no edges initially)
        for (int i = 0; i < V; i++) {
            for (int j = 0; j < V; j++) {
                adjMatrix[i][j] = 0;
            }
        }
    }

    // Destructor to free allocated memory
    ~Graph() {
        for (int i = 0; i < V; i++) {
            delete[] adjMatrix[i];
        }
        delete[] adjMatrix;
    }
};
```

**Explanation:**

- The `Graph` class stores the number of vertices in `V` and uses `adjMatrix` as a pointer to create a dynamic 2D array.
- The constructor allocates the 2D matrix and initializes all values to zero, indicating no edges.
- The destructor cleans up to prevent memory leaks.

***

### Step 2: Add Method to Insert Edges — `addEdge`

```cpp
    // Add an undirected edge between vertex u and vertex v
    void addEdge(int u, int v) {
        // Mark the presence of an edge in both directions
        adjMatrix[u][v] = 1;
        adjMatrix[v][u] = 1;
    }
```

**Explanation:**

- This method adds an edge between vertices `u` and `v` by setting both entries in the adjacency matrix to 1.
- This ensures that the edge is undirected, as the connection is bidirectional in the matrix.

***

### Step 3: Add Method to Display the Matrix — `printMatrix`

```cpp
    // Print the adjacency matrix
    void printMatrix() {
        cout << "Adjacency Matrix:\n  ";
        for (int i = 0; i < V; i++)
            cout << i << " ";
        cout << endl;

        for (int i = 0; i < V; i++) {
            cout << i << " ";
            for (int j = 0; j < V; j++) {
                cout << adjMatrix[i][j] << " ";
            }
            cout << endl;
        }
    }
```

**Explanation:**

- Prints the column headers as vertex indices.
- Iterates row by row, printing the vertex index followed by all values in that row.
- This visually presents which vertices are connected.

***

### Visual Representation of the Output

Assume a graph with 4 vertices $0, 1, 2, 3$ and edges:

- 0 ⟷ 1
- 0 ⟷ 2
- 1 ⟷ 2
- 2 ⟷ 3

The printed adjacency matrix will be:

```
Adjacency Matrix:
  0 1 2 3
0 0 1 1 0
1 1 0 1 0
2 1 1 0 1
3 0 0 1 0
```

- Here rows and columns represent vertices.
- `1` indicates an edge between the two vertices.
- For example, row 0: edges to vertices 1 and 2 (`1` at positions 1 and 2).
- Symmetry shows edges are undirected.

***

### Summary:

- This adjacency matrix implementation uses a dynamic 2D array for flexibility.
- The class provides clear methods to add edges and print the matrix.
- This representation is efficient when the graph is dense (lots of edges) since it allows $O(1)$ edge existence checks.
- The visual matrix output provides an intuitive snapshot of graph connectivity.

***


## 2. Adjacency List


***

#### Explanation:

- Represents the graph as an **array or list of lists**.
- Each vertex stores a list of adjacent vertices (neighbors).
- Efficient for **sparse graphs** since only existing edges are stored.
- **Space:** $O(V + E)$, where $E$ is the number of edges.
- Good for iterating over neighbors quickly.
- In weighted graphs, neighbors are stored with corresponding edge weights.

***

#### Visual Example:

```
Graph with vertices: A, B, C

Edges:
A -- B
B -- C

Adjacency List:

A: B
B: A, C
C: B

- Each vertex points to a list of its neighbors.
- Shows clear direct connectivity without extra unused space.
```


***

## Graph Representation Using Adjacency List in C++

### Step 1: Define the Graph Class and Initialize the Adjacency List

```cpp
#include <iostream>
#include <list>
using namespace std;

class Graph {
private:
    int V;                // Number of vertices
    list<int> *adj;       // Pointer to array of adjacency lists

public:
    // Constructor to initialize adjacency list
    Graph(int vertices) {
        V = vertices;
        adj = new list<int>[V];   // Create an array of lists for each vertex
    }

    // Destructor to free allocated memory
    ~Graph() {
        delete[] adj;
    }
};
```

**Explanation:**

- The `Graph` class stores the total vertices `V`.
- `adj` points to a dynamically allocated array of lists.
- Each list corresponds to the neighbors of a vertex.
- The constructor initializes this array.
- The destructor cleans up the allocated memory.

***

### Step 2: Add Method to Insert Edges — `addEdge`

```cpp
    // Add an undirected edge between vertex u and vertex v
    void addEdge(int u, int v) {
        adj[u].push_back(v);  // Add v to u's adjacency list
        adj[v].push_back(u);  // Since undirected, add u to v's list also
    }
```

**Explanation:**

- Adds vertex `v` to `u`’s adjacency list and vice versa.
- Represents an undirected edge connecting both vertices.
- Using `push_back` appends neighbors efficiently.

***

### Step 3: Add Method to Print the Graph — `printGraph`

```cpp
    // Print the adjacency list representation
    void printGraph() {
        for (int i = 0; i < V; i++) {
            cout << "Vertex " << i << ":";
            for (auto v : adj[i]) {
                cout << " -> " << v;
            }
            cout << endl;
        }
    }
```

**Explanation:**

- Iterates through each vertex.
- Prints the vertex followed by its adjacent vertices in list form.
- Clearly visualizes graph connectivity.

***

### Visual Representation of the Output

For a graph with vertices $0, 1, 2, 3$ and edges:

- 0 ⟷ 1
- 0 ⟷ 2
- 1 ⟷ 2
- 2 ⟷ 3

The printed adjacency list will be:

```
Vertex 0: -> 1 -> 2
Vertex 1: -> 0 -> 2
Vertex 2: -> 0 -> 1 -> 3
Vertex 3: -> 2
```

- Each line shows a vertex and its direct connections.
- For example, vertex 2 is connected to 0, 1, and 3.

***

### Summary:

- Adjacency list representation stores only existing edges, saving memory for sparse graphs.
- It is well-suited for graph traversal and iteration over neighbors.
- The class provides clear methods for adding edges and printing the graph structure.
- Visualization of adjacency lists makes it easy to understand direct neighbors of every vertex.

***

### Comparison Table

| Representation | Space Complexity | Edge Query Complexity | Neighbor Access Complexity | Suitable For |
| :-- | :-- | :-- | :-- | :-- |
| Adjacency Matrix | $O(V^2)$ | $O(1)$ | $O(V)$ | Dense graphs, fast edge checks |
| Adjacency List | $O(V + E)$ | $O(k)$ | $O(k)$ | Sparse graphs, efficient traversal |

- $V$ = number of vertices, $E$ = number of edges, $k$ = degree of a vertex.

***

## Summary:

- **Adjacency Matrix** uses a fixed-size 2D matrix; best when the graph is dense.
- **Adjacency List** uses dynamic lists per vertex; better space usage for sparse graphs.
- Choice depends on graph size, density, and operations required.

***
